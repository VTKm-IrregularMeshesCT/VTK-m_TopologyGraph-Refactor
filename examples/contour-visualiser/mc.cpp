//============================================================================
// Copyright (c) 2019, The Regents of the University of California, through
// Lawrence Berkeley National Laboratory (subject to receipt of any required approvals
// from the U.S. Dept. of Energy).  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
// (1) Redistributions of source code must retain the above copyright notice, this
//     list of conditions and the following disclaimer.
//
// (2) Redistributions in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//
// (3) Neither the name of the University of California, Lawrence Berkeley National
//     Laboratory, U.S. Dept. of Energy nor the names of its contributors may be
//     used to endorse or promote products derived from this software without
//     specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
// OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
// OF THE POSSIBILITY OF SUCH DAMAGE.
//============================================================================

#include "./mc.h"

#include <vtkm/filter/contour/Contour.h>

using namespace std;
using namespace vtkm;

cont::ArrayHandle<cv1k::Triangle> cv1k::mc::getMarchingCubeTriangles(cont::DataSet inputData,
                                                                     vector<Float64> isovalues,
                                                                     std::string fieldName)
{
    std::cout << "getMarchingCubeTriangles for these isovalues:" << std::endl;

    for (auto isovalue : isovalues)
    {
        std::cout << isovalue << std::endl;
    }

    // Run VTK-m built-in marching cubes (Contour) filter.
    vtkm::filter::contour::Contour contourFilter;
    contourFilter.SetGenerateNormals(true);
    contourFilter.SetAddInterpolationEdgeIds(true);
    contourFilter.SetMergeDuplicatePoints(true);
    contourFilter.SetIsoValues(isovalues);
    contourFilter.SetActiveField(fieldName);

    vtkm::cont::DataSet isoSurfaceOutput = contourFilter.Execute(inputData);

    // Convert to a concrete CellSet type (single type, safe assumption for contour).
    vtkm::cont::CellSetSingleType<> cellSet;
    isoSurfaceOutput.GetCellSet().AsCellSet(cellSet);

    vtkm::Id numCells = cellSet.GetNumberOfCells();

    std::cout << "We have this many cells - " << numCells << std::endl;

    // Get the coordinates
    auto coordsArray = isoSurfaceOutput.GetCoordinateSystem().GetDataAsMultiplexer();

  //  // Get edge ids field generated by contour
  //  auto edgeIdsArray =
  //      isoSurfaceOutput.GetField("edgeIds").GetData().AsArrayHandle<vtkm::Vec<vtkm::Id, 2>>();

    vtkm::cont::ArrayHandle<vtkm::Vec<vtkm::Id, 2>> edgeIdsArray;
    // safer way to get the edge endpoints
    try {
        isoSurfaceOutput.GetField("edgeIds").GetData().AsArrayHandle(edgeIdsArray);
    }
    catch (const vtkm::cont::ErrorBadType& error)
    {
        std::cerr << "Error in casting edgeIds array: " << error.GetMessage() << std::endl;
        throw;
    }

    vtkm::cont::ArrayHandle<cv1k::Triangle> triangles;
    triangles.Allocate(numCells);

    // Get portals once outside the loop (efficient way, easy-to-read)
    auto trianglePortal = triangles.WritePortal();
    auto coordsPortal = coordsArray.ReadPortal();
    auto edgeIdsPortal = edgeIdsArray.ReadPortal();


    // Extract triangles from the MC output cell mesh
    for(vtkm::Id cellId = 0; cellId < numCells; ++cellId)
    {
        //        std::cout << "TRIANGLE #" << cellId << std::endl;

        // retrieve the ID of the vertices from the marching tets output
        // this will not be the same as any of our usual (such as regular) IDs
        vtkm::Id pointIds[3];
        cellSet.GetCellPointIds(cellId, pointIds);

        // Get regular IDs of the endpoints for interpolation edge

        // start by retrieving the ID
        // we take the 0th point because it does not matter
        // (all vertices of the triangle will map to the same superarc of the contour tree)
        vtkm::Vec<vtkm::Id,2> regularEdge = edgeIdsPortal.Get(pointIds[0]);

        // Need to tranverse the hyperstructure here to get the correct superarc:
        // --------------------------------------- STEP D --------------------------------------------- //


        // Get endpoint vertex IDs to the unsorted scalar field array:
        vtkm::Id regularID1 = regularEdge[0];
        vtkm::Id regularID2 = regularEdge[1];
        // Set the triangle id and coordinates
//        triangles.GetPortalControl().Set(i,
//            { -1,
//                edgeIdPortal.Get(pointIds[0]),
//                { coordinatesPortal.Get(pointIds[0]), coordinatesPortal.Get(pointIds[1]), coordinatesPortal.Get(pointIds[2]) } });

        cv1k::Triangle tri; // run the default constructor, sets sentinel values for each member variable
        tri.superarcId         = -1; // the superarc ID is being set in the constructor, just being paranoid here
        tri.representativeEdge = regularEdge;
        tri.points[0] = coordsPortal.Get(pointIds[0]);
        tri.points[1] = coordsPortal.Get(pointIds[1]);
        tri.points[2] = coordsPortal.Get(pointIds[2]);

//        // Hack: Set these edge fields to Ids because currently those EdgeIds are whats written to the VTK file for colouring
//        tri.representativeEdge[0] = tri.Id;
//        tri.representativeEdge[1] = tri.Id;

        trianglePortal.Set(cellId, tri);

    }

    std::cout << "returning the triangles" << std::endl;

    return triangles;
}

